//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Tue Feb  4 15:26:41 IST 2020
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTestbench(CLK,
		   RST_N);
  input  CLK;
  input  RST_N;

  // register doneSet
  reg doneSet;
  wire doneSet$D_IN, doneSet$EN;

  // register rgChkComplete
  reg rgChkComplete;
  wire rgChkComplete$D_IN, rgChkComplete$EN;

  // register rgCurInput
  reg [15 : 0] rgCurInput;
  wire [15 : 0] rgCurInput$D_IN;
  wire rgCurInput$EN;

  // register rgCurInput1
  reg [15 : 0] rgCurInput1;
  wire [15 : 0] rgCurInput1$D_IN;
  wire rgCurInput1$EN;

  // register rgCurOutput
  reg [15 : 0] rgCurOutput;
  wire [15 : 0] rgCurOutput$D_IN;
  wire rgCurOutput$EN;

  // register rgCurOutput1
  reg [15 : 0] rgCurOutput1;
  wire [15 : 0] rgCurOutput1$D_IN;
  wire rgCurOutput1$EN;

  // register rgError
  reg rgError;
  wire rgError$D_IN, rgError$EN;

  // register rgGenComplete
  reg rgGenComplete;
  wire rgGenComplete$D_IN, rgGenComplete$EN;

  // register wrongOut
  reg [31 : 0] wrongOut;
  wire [31 : 0] wrongOut$D_IN;
  wire wrongOut$EN;

  // ports of submodule dut
  wire [31 : 0] dut$compute_request_put;
  wire [16 : 0] dut$compute_response_get;
  wire dut$EN_compute_request_put,
       dut$EN_compute_response_get,
       dut$RDY_compute_request_put,
       dut$RDY_compute_response_get;

  // ports of submodule ffInputVals
  wire [15 : 0] ffInputVals$D_IN, ffInputVals$D_OUT;
  wire ffInputVals$CLR,
       ffInputVals$DEQ,
       ffInputVals$EMPTY_N,
       ffInputVals$ENQ,
       ffInputVals$FULL_N;

  // ports of submodule ffInputVals1
  wire [15 : 0] ffInputVals1$D_IN, ffInputVals1$D_OUT;
  wire ffInputVals1$CLR,
       ffInputVals1$DEQ,
       ffInputVals1$EMPTY_N,
       ffInputVals1$ENQ,
       ffInputVals1$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_lfsrGenerate,
       CAN_FIRE_RL_rlCheck,
       CAN_FIRE_RL_rlFinish,
       CAN_FIRE_RL_rlGenerate,
       WILL_FIRE_RL_lfsrGenerate,
       WILL_FIRE_RL_rlCheck,
       WILL_FIRE_RL_rlFinish,
       WILL_FIRE_RL_rlGenerate;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h1003;
  reg [63 : 0] v__h1365;
  reg [63 : 0] v__h1332;
  // synopsys translate_on

  // remaining internal signals
  wire [15 : 0] expected__h958, x__h1216, x__h799;
  wire NOT_dut_compute_response_get_0_BITS_15_TO_0_1__ETC___d36;

  // submodule dut
  mkPNE_test dut(.CLK(CLK),
		 .RST_N(RST_N),
		 .compute_request_put(dut$compute_request_put),
		 .EN_compute_request_put(dut$EN_compute_request_put),
		 .EN_compute_response_get(dut$EN_compute_response_get),
		 .RDY_compute_request_put(dut$RDY_compute_request_put),
		 .compute_response_get(dut$compute_response_get),
		 .RDY_compute_response_get(dut$RDY_compute_response_get));

  // submodule ffInputVals
  SizedFIFO #(.p1width(32'd16),
	      .p2depth(32'd22),
	      .p3cntr_width(32'd5),
	      .guarded(32'd1)) ffInputVals(.RST(RST_N),
					   .CLK(CLK),
					   .D_IN(ffInputVals$D_IN),
					   .ENQ(ffInputVals$ENQ),
					   .DEQ(ffInputVals$DEQ),
					   .CLR(ffInputVals$CLR),
					   .D_OUT(ffInputVals$D_OUT),
					   .FULL_N(ffInputVals$FULL_N),
					   .EMPTY_N(ffInputVals$EMPTY_N));

  // submodule ffInputVals1
  SizedFIFO #(.p1width(32'd16),
	      .p2depth(32'd22),
	      .p3cntr_width(32'd5),
	      .guarded(32'd1)) ffInputVals1(.RST(RST_N),
					    .CLK(CLK),
					    .D_IN(ffInputVals1$D_IN),
					    .ENQ(ffInputVals1$ENQ),
					    .DEQ(ffInputVals1$DEQ),
					    .CLR(ffInputVals1$CLR),
					    .D_OUT(ffInputVals1$D_OUT),
					    .FULL_N(ffInputVals1$FULL_N),
					    .EMPTY_N(ffInputVals1$EMPTY_N));

  // rule RL_lfsrGenerate
  assign CAN_FIRE_RL_lfsrGenerate = !doneSet ;
  assign WILL_FIRE_RL_lfsrGenerate = CAN_FIRE_RL_lfsrGenerate ;

  // rule RL_rlGenerate
  assign CAN_FIRE_RL_rlGenerate =
	     dut$RDY_compute_request_put && ffInputVals$FULL_N &&
	     ffInputVals1$FULL_N &&
	     !rgGenComplete &&
	     doneSet ;
  assign WILL_FIRE_RL_rlGenerate = CAN_FIRE_RL_rlGenerate ;

  // rule RL_rlCheck
  assign CAN_FIRE_RL_rlCheck =
	     dut$RDY_compute_response_get && ffInputVals$EMPTY_N &&
	     ffInputVals1$EMPTY_N &&
	     !rgChkComplete &&
	     doneSet ;
  assign WILL_FIRE_RL_rlCheck = CAN_FIRE_RL_rlCheck ;

  // rule RL_rlFinish
  assign CAN_FIRE_RL_rlFinish = rgChkComplete && doneSet ;
  assign WILL_FIRE_RL_rlFinish = CAN_FIRE_RL_rlFinish ;

  // register doneSet
  assign doneSet$D_IN = 1'd1 ;
  assign doneSet$EN = CAN_FIRE_RL_lfsrGenerate ;

  // register rgChkComplete
  assign rgChkComplete$D_IN = rgCurOutput == 16'd65535 ;
  assign rgChkComplete$EN = CAN_FIRE_RL_rlCheck ;

  // register rgCurInput
  assign rgCurInput$D_IN = rgCurInput + 16'd1 ;
  assign rgCurInput$EN = WILL_FIRE_RL_rlGenerate && rgCurInput1 == 16'd65535 ;

  // register rgCurInput1
  assign rgCurInput1$D_IN = (rgCurInput1 == 16'd65535) ? 16'd0 : x__h799 ;
  assign rgCurInput1$EN = CAN_FIRE_RL_rlGenerate ;

  // register rgCurOutput
  assign rgCurOutput$D_IN = rgCurOutput + 16'd1 ;
  assign rgCurOutput$EN = WILL_FIRE_RL_rlCheck && rgCurOutput1 == 16'd65535 ;

  // register rgCurOutput1
  assign rgCurOutput1$D_IN = (rgCurOutput1 == 16'd65535) ? 16'd0 : x__h1216 ;
  assign rgCurOutput1$EN = CAN_FIRE_RL_rlCheck ;

  // register rgError
  assign rgError$D_IN = 1'd1 ;
  assign rgError$EN =
	     WILL_FIRE_RL_rlCheck &&
	     NOT_dut_compute_response_get_0_BITS_15_TO_0_1__ETC___d36 ;

  // register rgGenComplete
  assign rgGenComplete$D_IN =
	     rgCurInput == 16'd65535 && rgCurInput1 == 16'd65535 ;
  assign rgGenComplete$EN = CAN_FIRE_RL_rlGenerate ;

  // register wrongOut
  assign wrongOut$D_IN = wrongOut + 32'd1 ;
  assign wrongOut$EN =
	     WILL_FIRE_RL_rlCheck &&
	     NOT_dut_compute_response_get_0_BITS_15_TO_0_1__ETC___d36 ;

  // submodule dut
  assign dut$compute_request_put = { rgCurInput, rgCurInput1 } ;
  assign dut$EN_compute_request_put = CAN_FIRE_RL_rlGenerate ;
  assign dut$EN_compute_response_get = CAN_FIRE_RL_rlCheck ;

  // submodule ffInputVals
  assign ffInputVals$D_IN = rgCurInput ;
  assign ffInputVals$ENQ = CAN_FIRE_RL_rlGenerate ;
  assign ffInputVals$DEQ = CAN_FIRE_RL_rlCheck ;
  assign ffInputVals$CLR = 1'b0 ;

  // submodule ffInputVals1
  assign ffInputVals1$D_IN = rgCurInput1 ;
  assign ffInputVals1$ENQ = CAN_FIRE_RL_rlGenerate ;
  assign ffInputVals1$DEQ = CAN_FIRE_RL_rlCheck ;
  assign ffInputVals1$CLR = 1'b0 ;

  // remaining internal signals
  assign NOT_dut_compute_response_get_0_BITS_15_TO_0_1__ETC___d36 =
	     dut$compute_response_get[15:0] != expected__h958 ;
  assign expected__h958 =
	     $imported_positAdd16(ffInputVals$D_OUT, ffInputVals1$D_OUT) ;
  assign x__h1216 = rgCurOutput1 + 16'd1 ;
  assign x__h799 = rgCurInput1 + 16'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        doneSet <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rgChkComplete <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rgCurInput <= `BSV_ASSIGNMENT_DELAY 16'd0;
	rgCurInput1 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	rgCurOutput <= `BSV_ASSIGNMENT_DELAY 16'd0;
	rgCurOutput1 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	rgError <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rgGenComplete <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wrongOut <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (doneSet$EN) doneSet <= `BSV_ASSIGNMENT_DELAY doneSet$D_IN;
	if (rgChkComplete$EN)
	  rgChkComplete <= `BSV_ASSIGNMENT_DELAY rgChkComplete$D_IN;
	if (rgCurInput$EN)
	  rgCurInput <= `BSV_ASSIGNMENT_DELAY rgCurInput$D_IN;
	if (rgCurInput1$EN)
	  rgCurInput1 <= `BSV_ASSIGNMENT_DELAY rgCurInput1$D_IN;
	if (rgCurOutput$EN)
	  rgCurOutput <= `BSV_ASSIGNMENT_DELAY rgCurOutput$D_IN;
	if (rgCurOutput1$EN)
	  rgCurOutput1 <= `BSV_ASSIGNMENT_DELAY rgCurOutput1$D_IN;
	if (rgError$EN) rgError <= `BSV_ASSIGNMENT_DELAY rgError$D_IN;
	if (rgGenComplete$EN)
	  rgGenComplete <= `BSV_ASSIGNMENT_DELAY rgGenComplete$D_IN;
	if (wrongOut$EN) wrongOut <= `BSV_ASSIGNMENT_DELAY wrongOut$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    doneSet = 1'h0;
    rgChkComplete = 1'h0;
    rgCurInput = 16'hAAAA;
    rgCurInput1 = 16'hAAAA;
    rgCurOutput = 16'hAAAA;
    rgCurOutput1 = 16'hAAAA;
    rgError = 1'h0;
    rgGenComplete = 1'h0;
    wrongOut = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlCheck &&
	  NOT_dut_compute_response_get_0_BITS_15_TO_0_1__ETC___d36)
	begin
	  v__h1003 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlCheck &&
	  NOT_dut_compute_response_get_0_BITS_15_TO_0_1__ETC___d36)
	$display("[%0d]::ERR::Input=%b::Input2=%b::Expected Output=%b::Output=%b",
		 v__h1003,
		 ffInputVals$D_OUT,
		 ffInputVals1$D_OUT,
		 expected__h958,
		 dut$compute_response_get[15:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlFinish) $display("%d", wrongOut);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlFinish && rgError)
	begin
	  v__h1365 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlFinish && rgError)
	$display("[%0d]::INF::with errors found.", v__h1365);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlFinish && !rgError)
	begin
	  v__h1332 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlFinish && !rgError)
	$display("[%0d]::INF::No errors found.", v__h1332);
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_rlFinish) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkTestbench

